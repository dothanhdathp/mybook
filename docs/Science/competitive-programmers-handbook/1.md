# Chapter 1: Introduction

Lập trình cạnh tranh kết hợp hai chủ đề:

1. thiết kế của các thuật toán và
2. Việc thực hiện các thuật toán.

Thiết kế của các thuật toán bao gồm giải quyết vấn đề và tư duy toán học.Kỹ năng phân tích các vấn đề và giải quyết chúng một cách sáng tạo là cần thiết.Một thuật toán để giải quyết một vấn đề phải vừa chính xác và hiệu quả, và cốt lõi của vấn đề thường là về việc phát minh ra một thuật toán hiệu quả.

Kiến thức lý thuyết về các thuật toán là quan trọng đối với các lập trình viên cạnh tranh.Thông thường, một giải pháp cho một vấn đề là sự kết hợp của các kỹ thuật nổi tiếng và những hiểu biết mới.Các kỹ thuật xuất hiện trong lập trình cạnh tranh cũng tạo thành cơ sở cho nghiên cứu khoa học của các thuật toán.

Việc thực hiện các thuật toán đòi hỏi kỹ năng lập trình tốt.Trong lập trình cạnh tranh, các giải pháp được phân loại bằng cách kiểm tra một thuật toán được triển khai bằng cách sử dụng một tập hợp các trường hợp thử nghiệm.Do đó, không đủ ý tưởng về thuật toán là chính xác, nhưng việc thực hiện cũng phải đúng.

Một phong cách mã hóa tốt trong các cuộc thi là đơn giản và súc tích.Các chương trình nên được viết nhanh chóng, vì không có nhiều thời gian.Không giống như trong kỹ thuật phần mềm truyền thống, các chương trình ngắn (thường là nhiều nhất vài trăm dòng mã) và chúng không cần phải được duy trì sau cuộc thi.

## Programming languages

Hiện tại, các ngôn ngữ lập trình phổ biến nhất được sử dụng trong các cuộc thi là `C++`, Python và Java.Ví dụ, trong Google Code Jam 2017, trong số 3.000 người tham gia tốt nhất, 79 % đã sử dụng `C++`, 16 % đã sử dụng Python và 8 % đã sử dụng Java.Một số người tham gia cũng sử dụng một số ngôn ngữ.

Nhiều người nghĩ rằng `C++` là lựa chọn tốt nhất cho một lập trình viên cạnh tranh và `C++` gần như luôn có sẵn trong các hệ thống cuộc thi.Lợi ích của việc sử dụng `C++` là nó là một ngôn ngữ rất hiệu quả và thư viện tiêu chuẩn của nó chứa một bộ sưu tập lớn các cấu trúc và thuật toán dữ liệu.

Mặt khác, thật tốt khi làm chủ một số ngôn ngữ và hiểu điểm mạnh của chúng.Ví dụ: nếu các số nguyên lớn là cần thiết trong vấn đề, Python có thể là một lựa chọn tốt, bởi vì nó chứa các hoạt động tích hợp để tính toán với các số nguyên lớn.Tuy nhiên, hầu hết các vấn đề trong các cuộc thi lập trình được đặt ra để sử dụng một ngôn ngữ lập trình cụ thể không phải là một lợi thế không công bằng.

Tất cả các chương trình ví dụ trong cuốn sách này được viết bằng `C++` và các cấu trúc và thuật toán dữ liệu thư viện tiêu chuẩn thường được sử dụng.Các chương trình tuân theo tiêu chuẩn `C++` 11, có thể được sử dụng trong hầu hết các cuộc thi hiện nay.Nếu bạn không thể lập trình trong `C++`, bây giờ là thời điểm tốt để bắt đầu học hỏi.

### C++ code template

Đặc trưng mẫu mã cho lập trình `C++` trông như thế này:
```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    // solution comes here
}
```

Cụm từ `#include` trong dòng đầu tiên là tính năng của trình biên dịch `g++`, cho phép chúng ta thêm vào toàn bộ các thư viện cơ bản. Do đó, nó không cần thiết để bao gồm các thư viện như `iostream`, `vector` và `algorithm`, nhưng đúng hơn là chúng có sẵn.

Dòng `using` tuyên bố rằng các lớp và chức năng của thư viện tiêu chuẩn có thể được sử dụng trực tiếp trong mã. Không có dòng sử dụng, chúng tôi sẽ phải viết, ví dụ, `std::cout`, Nhưng bây giờ nó đủ để viết là `cout`.

Mã có thể được biên dịch bằng lệnh sau:

```bash
g++ -std=c++11 -O2 -Wall test.cpp -o test
```

Lệnh này tạo ra một thử nghiệm tệp nhị phân từ mã nguồn `test.cpp`. Trình biên dịch theo sau ___C++11 standard___ (`-std=c++11`), Tối ưu hóa mã (`-O2`) và cho thấy cảnh báo về các lỗi có thể xảy ra (`-Wall`).

## Input and output (Đầu Vào và Đầu Ra)

Trong hầu hết các cuộc thi, các luồng tiêu chuẩn được sử dụng để đọc đầu vào và viết đầu ra.

Trong `C ++`, các luồng tiêu chuẩn là CIN cho đầu vào và cout cho đầu ra. Ngoài ra, có thể sử dụng các hàm C `scanf` và` printf`.

Đầu vào cho chương trình thường bao gồm các số và chuỗi được phân tách bằng <u>dấu cách</u> hoặc <u>xuống dòng mới</u>. Chúng có thể được đọc từ luồng `cin` như sau:

```cpp
int a, b;
string x;
cin >> a >> b >> x;
```

This kind of code always works, assuming that there is at least one space or newline between each element in the input. For example, the above code can read both of the following inputs:

```txt
123 456 monkey
123
456
monkey
```

Luồng Cout được sử dụng cho đầu ra như sau:

```cpp
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
```

Đầu vào và đầu ra đôi khi là một nút cổ chai trong chương trình. Các dòng sau ở đầu mã làm cho đầu vào và đầu ra hiệu quả hơn:

```cpp
ios::sync_with_stdio(0);
cin.tie(0);
```

Lưu ý rằng dòng mới `\n` hoạt động nhanh hơn `endl`, vì `endl` luôn tạo ra hoạt động ___flush___.

Các hàm C Scanf và printf là một giải pháp thay thế cho các luồng tiêu chuẩn C ++. Chúng thường nhanh hơn một chút, nhưng chúng cũng khó sử dụng hơn. Mã sau đọc hai số nguyên từ đầu vào:

```cpp
int a, b;
scanf("%d %d", &a, &b);
```

Mã sau in hai số nguyên:

```cpp
int a = 123, b = 456;
printf("%d %d\n", a, b);
```

Đôi khi chương trình nên đọc toàn bộ dòng từ đầu vào, có thể chứa khoảng trắng. Điều này có thể được thực hiện bằng cách sử dụng chức năng GetLine:

```cpp
string s;
getline(cin, s);
```

Nếu không rõ lượng dữ liệu, vòng lặp sau đây hữu ích:

```cpp
while (cin >> x) {
    // code
}
```

Vòng lặp này đọc các phần tử từ đầu vào lần lượt, cho đến khi không còn dữ liệu nào trong đầu vào.

Trong một số hệ thống cuộc thi, các tập tin được sử dụng cho đầu vào và đầu ra. Một giải pháp dễ dàng cho điều này là viết mã như thông thường bằng cách sử dụng các _luồng tiêu chuẩn_, nhưng thêm các dòng sau vào đầu mã:

```cpp
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```

Sau đó, chương trình đọc đầu vào từ tệp `input.txt` và ghi đầu ra vào tệp` oput.txt`.

## Làm việc với con số _Numbers_

### Integers

Loại số nguyên _(integers)_ được sử dụng nhiều nhất trong lập trình cạnh tranh là int, đây là loại `32 bit` với phạm vi giá trị của nó từ $−2^{31} ... 2^{31} − 1$ or about ${−2}\cdot{10^{9}} ... {2}\cdot{10^{9}}$. If the type int is not enough, the 64-bit type long long can be used. It has a value range of $−2^{63}...2^{63}−1$ or about ${−9}\cdot{10^{18}}...{9}\cdot{10^{18}}$.

Mã sau xác định một biến `long long`:

```cpp
long long x = 123456789123456789LL;
```

Hậu tố `LL` có nghĩa là loại số là `long long`.

Một sai lầm phổ biến khi sử dụng `long long` là loại 'số học' vẫn được sử dụng ở đâu đó trong mã. Lấy ví dụ: mã sau chứa lỗi tinh tế:

```cpp
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
```

Mặc dù biến `b` là loại `long long`, Cả hai số trong biểu thức $a*a$ thuộc loại `int` và kết quả cũng thuộc loại `int`. Bởi vì điều này, biến B sẽ chứa một kết quả sai. Vấn đề có thể được giải quyết bằng cách thay đổi loại thành `long long`hoặc bằng cách thay đổi biểu thức thành (`long long`) $a*a$. Thông thường các vấn đề cuộc thi được đặt sao cho loại `long long` là đủ.Tuy nhiên, thật tốt khi biết rằng `g++`Trình biên dịch cũng cung cấp một `128-bit` kiểu `__int128_t` với phạm vi giá trị của $−2^{127}...2^{127}−1$ hoặc về $−10^{38}...10^{38}$. Tuy nhiên, loại này không có sẵn trong tất cả các hệ thống cuộc thi.

### Modular arithmetic _(Số học modular)_

Chúng tôi biểu thị bằng ${x}\mod{m}$ phần còn lại khi `x` được chia cho `m`. Ví dụ, ${17}\mod{5}=2$, bởi vì $17={3}\cdot{5}+2$.

Thỉnh thoảng, câu trả lời cho vấn đề là một số cực kỳ, cực kỳ lớn nhưng nó vẫn đủ để trình bày nó dưới dạng ___modulo m___, i.e., phần còn lại khi câu trả lời được chia cho M (ví dụ, Modulo 109 +7). Ý tưởng là ngay cả khi câu trả lời thực tế là rất lớn, nó đủ để sử dụng các loại int và dài.

Một tài sản quan trọng của phần còn lại là trong `addition`, `subtraction` và `multiplication`, phần còn lại có thể được thực hiện trước khi hoạt động:

$$
{(a+b)}\mod{m}=(a\mod{m} + b\mod{m})\mod{m} \\
{(a−b)}\mod{m}=(a\mod{m} − b\mod{m})\mod{m} \\
{(a\cdot{b})}\mod{m}=(a\mod{m} \cdot b\mod{m})\mod{m}
$$

Do đó, chúng ta có thể lấy phần còn lại sau mỗi hoạt động và các con số sẽ không bao giờ trở nên quá lớn.

Ví dụ: mã sau tính toán `n!`, các giai thừa _(factorial)_ of `n`, ___modulo___ `m`:

```cpp
long long x = 1;

for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}

cout << x%m << "\n";
```

Thông thường chúng luôn muốn phần Còn lại luôn ở giữa $0 ... m-1$. Tuy nhiên, trong `C++` và các ngôn ngữ khác, phần còn lại của số âm là __0__ hoặc __âm__. Một cách dễ dàng để đảm bảo không có phần còn lại tiêu cực là tính toán phần còn lại như bình thường và sau đó thêm `m` nếu kết quả là __âm__:

```cpp
x = x%m;
if (x < 0) x += m;
```

Tuy nhiên, điều này chỉ cần thiết khi có các phép trừ trong mã và phần còn lại có thể trở nên âm.

### Floating point numbers

Các loại điểm nổi thông thường trong lập trình cạnh tranh là `64-bit` ___double___ và, như một phần mở rộng trong __g++ compiler__, `80-bit` `long` `double`. Trong hầu hết trường hợp, `double` là đủ dùng, nhưng `long double` có độ chính xác cao hơn.

Độ chính xác cần thiết của câu trả lời thường được đưa ra trong báo cáo vấn đề. Một cách dễ dàng để xuất câu trả lời là sử dụng hàm `printf` và đưa ra số lượng vị trí thập phân trong chuỗi định dạng. Ví dụ: mã sau in giá trị của `x` Với 9 số thập phân:

```cpp
printf("%.9f\n", x);
```

Một khó khăn khi sử dụng số điểm nổi là một số số không thể được biểu diễn chính xác dưới dạng số điểm nổi và sẽ có lỗi làm tròn. Ví dụ, kết quả của mã sau là đáng ngạc nhiên:

```cpp
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
```

Do lỗi làm tròn, giá trị của x nhỏ hơn 1, trong khi giá trị chính xác sẽ `1`.

Thật rủi ro khi so sánh các số điểm nổi với toán tử ==, bởi vì có thể các giá trị phải bằng nhau nhưng chúng không phải vì lỗi chính xác. Một cách tốt hơn để so sánh các số điểm nổi là giả định rằng hai số bằng nhau nếu sự khác biệt giữa chúng nhỏ hơn ε, trong đó là một số nhỏ.

Trong thực tế, các con số có thể được so sánh như sau $(\varepsilon=10^{−9})$:

```cpp
if (abs(a-b) < 1e-9) {
// a and b are equal
}
```

Lưu ý rằng trong khi số điểm nổi là không chính xác, các số nguyên cho đến một giới hạn nhất định vẫn có thể được biểu diễn chính xác. Ví dụ: sử dụng `double`, có thể thể hiện chính xác tất cả các số nguyên có giá trị tuyệt đối nhất $2^53$.

## Shortening code - lập trình ngắn hơn

Mã ngắn là lý tưởng trong lập trình cạnh tranh, bởi vì các chương trình nên được viết nhanh nhất có thể. Bởi vì điều này, các lập trình viên cạnh tranh thường xác định tên ngắn hơn cho các kiểu dữ liệu và các phần khác của mã.

### Type names

Using the command typedef it is possible to give a shorter name to a datatype.

Ví dụ: tên dài dài, vì vậy chúng ta có thể xác định tên ngắn hơn `ll`: `typedef long long ll;` Sau đó, mã:

```cpp
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
```

Có thể rút ngắn như sau:

```cpp
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
```

Lệnh typedef cũng có thể được sử dụng với các loại phức tạp hơn. Ví dụ: mã sau đây cho tên VI cho một vectơ số nguyên và tên pi cho một cặp chứa hai số nguyên.

```cpp
typedef vector<int> vi;
typedef pair<int,int> pi;
```

### Macros

Một cách khác để rút ngắn mã là xác định macro. Một macro có nghĩa là một số chuỗi nhất định trong mã sẽ được thay đổi trước khi biên dịch. Trong C ++, các macro được xác định bằng cách sử dụng từ khóa #Define.

Ví dụ: chúng ta có thể xác định các macro sau:

```cpp
#define F first
#define S second
#define PB push_back
#define MP make_pair
```

Sau này, mã:

```cpp
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
```

Có thể rút ngắn như sau:

```cpp
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
```

Một macro cũng có thể có các tham số cho phép rút ngắn các vòng lặp và các cấu trúc khác. Ví dụ: chúng ta có thể xác định macro sau:

```cpp
#define REP(i,a,b) for (int i = a; i <= b; i++)
```

After this, the code

```cpp
for (int i = 1; i <= n; i++) {
    search(i);
}
```

Có thể rút ngắn như sau:

```cpp
REP(i,1,n) {
    search(i);
}
```

Đôi khi macro gây ra lỗi có thể khó phát hiện. Ví dụ, hãy xem xét các macro sau đây tính toán bình phương của một số:

```cpp
#define SQ(a) a*a
```

__Macro__ này không phải lúc nào cũng hoạt động như mong đợi. Ví dụ: mã

```cpc
cout << SQ(3+3) << "\n";
```

tương ứng với mã

```txt
cout << 3+3*3+3 << "\n"; // 15
```

Một phiên bản tốt hơn của macro như sau:

```txt
#define SQ(a) (a)*(a)
```

Bây giờ mã

```txt
cout << SQ(3+3) << "\n";
```

tương ứng với mã

```txt
cout << (3+3)*(3+3) << "\n"; // 36
```

## Mathematics _(Toán học)_

Toán học đóng một vai trò quan trọng trong lập trình cạnh tranh, và không thể trở thành một lập trình viên cạnh tranh thành công mà không có kỹ năng toán học tốt. Phần này thảo luận về một số khái niệm và công thức toán học quan trọng cần thiết sau này trong cuốn sách.

### Công thức tổng _(sum)_

Mỗi tổng của _biểu mẫu (form)_:
